import { ethers, network } from "hardhat";
import addressUtils from "../../utils/addressUtils";
import {
  ILayerZeroEndpoint__factory,
  LzSuperCall__factory,
} from "../../typechain-types";

const chainIds = require("../../constants/chainIds.json");
const endpoints = require("../../constants/layerzeroEndpoints.json");

async function main() {
  const [signer] = await ethers.getSigners();
  const addressList = await addressUtils.getAddressList(network.name);
  const endpoint = ILayerZeroEndpoint__factory.connect(
    endpoints[network.name],
    signer
  );

  // Inputs
  const srcChain = "bsc-testnet";
  const srcChainId = chainIds[srcChain];
  const srcAddrList = await addressUtils.getAddressList(srcChain);
  const srcAddr = srcAddrList["LzSuperCall"];
  const abiEncoder = new ethers.AbiCoder();
  const bytesSrcAddr = abiEncoder.encode(["address"], [srcAddr]);
  const payload =
    "0x000000000000000000000000000000000000000000000000000000000000277a00000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000cd61cd2b903e38c23e9b75989fa567defe1470f60000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000004c00000000000000000000000000000000000000000000000000000000000000028c951af9bcb81432f9688d8cf543a844f1e2677cecd61cd2b903e38c23e9b75989fa567defe1470f600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003800000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000277d0000000000000000000000000f127602472aa90e53df43eb42c0dfa4b4dc047000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000160000000000000000000000000cd61cd2b903e38c23e9b75989fa567defe1470f600000000000000000000000000000000000000000000000000030cf88f04dba3000000000000000000000000000000000000000000000000000000000000006441304fac0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000f48656c6c6f2066726f6d2066756a690000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000001a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000277a00000000000000000000000012131300ca945c57dab73edd39f268e7849aedc900000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000160000000000000000000000000c951af9bcb81432f9688d8cf543a844f1e2677ce0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006441304fac0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001b48656c6c6f2066726f6d206d756d6261692073756263616c6c203100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

  const hasStored = await endpoint.hasStoredPayload(
    srcChainId,
    "0x7d9cc980596f9ad1a972c4e6552dacb7a1ee1bbd"
  );
  console.log("hasStored: ", hasStored);

  // const tx = await endpoint.retryPayload(srcChainId, bytesSrcAddr, payload);

  // const receipt = await tx.wait();
  // console.log("Tx mined: ", receipt?.hash);
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
